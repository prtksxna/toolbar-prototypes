{"version":3,"sources":["oojs.js"],"names":["global","simpleArrayCombine","a","b","includeB","i","ilen","bObj","result","length","push","oo","hasOwn","hasOwnProperty","toString","initClass","fn","static","inheritClass","targetFn","originFn","targetConstructor","Error","prototype","constructor","parent","Object","create","value","enumerable","writable","configurable","mixinClass","key","call","isSubclass","testFn","baseFn","getProp","obj","retval","arguments","undefined","setProp","prop","deleteProp","props","pop","isPlainObject","keys","cloneObject","origin","r","getObjectValues","values","TypeError","binarySearch","arr","searchFunc","forInsertion","mid","cmpResult","left","right","compare","asymmetrical","aValue","bValue","aType","bType","k","nodeType","isEqualNode","copy","source","leafCallback","nodeCallback","destination","Array","isArray","clone","cloneNode","getHash","val","JSON","stringify","keySortReplacer","normalized","len","getHashObject","sort","unique","reduce","current","indexOf","simpleArrayUnion","j","jlen","simpleArrayIntersection","simpleArrayDifference","proto","getPrototypeOf","validateMethod","method","context","addBinding","ee","event","binding","bindings","EventEmitter","this","on","args","once","listener","off","splice","emit","slice","apply","concat","connect","methods","disconnect","normalizeArrayIndex","index","EmitterList","items","aggregateItemEvents","getItems","getItemIndex","item","getItemCount","isEmpty","aggregate","events","add","remove","itemEvent","groupEvent","addItems","oldIndex","moveItem","insertItem","newIndex","existingIndex","removeItems","clearItems","cleared","SortedEmitterList","sortingCallback","sortChange","itemSortChange","onItemSortChange","setSortingCallback","insertionIndex","findInsertionIndex","list","otherItem","Registry","registry","register","name","data","unregister","lookup","Factory","super","module","exports","OO"],"mappings":"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","file":"oojs.min.js","sourcesContent":["/*!\n * OOjs v2.1.0\n * https://www.mediawiki.org/wiki/OOjs\n *\n * Copyright 2011-2017 OOjs Team and other contributors.\n * Released under the MIT license\n * https://oojs.mit-license.org\n *\n * Date: 2017-05-30T22:56:52Z\n */\n( function ( global ) {\n\n'use strict';\n\n/* exported toString */\nvar\n\t/**\n\t * Namespace for all classes, static methods and static properties.\n\t * @class OO\n\t * @singleton\n\t */\n\too = {},\n\t// Optimisation: Local reference to Object.prototype.hasOwnProperty\n\thasOwn = oo.hasOwnProperty,\n\ttoString = oo.toString;\n\n/* Class Methods */\n\n/**\n * Utility to initialize a class for OO inheritance.\n *\n * Currently this just initializes an empty static object.\n *\n * @param {Function} fn\n */\noo.initClass = function ( fn ) {\n\tfn.static = fn.static || {};\n};\n\n/**\n * Inherit from prototype to another using Object#create.\n *\n * Beware: This redefines the prototype, call before setting your prototypes.\n *\n * Beware: This redefines the prototype, can only be called once on a function.\n * If called multiple times on the same function, the previous prototype is lost.\n * This is how prototypal inheritance works, it can only be one straight chain\n * (just like classical inheritance in PHP for example). If you need to work with\n * multiple constructors consider storing an instance of the other constructor in a\n * property instead, or perhaps use a mixin (see OO.mixinClass).\n *\n *     function Thing() {}\n *     Thing.prototype.exists = function () {};\n *\n *     function Person() {\n *         Person.super.apply( this, arguments );\n *     }\n *     OO.inheritClass( Person, Thing );\n *     Person.static.defaultEyeCount = 2;\n *     Person.prototype.walk = function () {};\n *\n *     function Jumper() {\n *         Jumper.super.apply( this, arguments );\n *     }\n *     OO.inheritClass( Jumper, Person );\n *     Jumper.prototype.jump = function () {};\n *\n *     Jumper.static.defaultEyeCount === 2;\n *     var x = new Jumper();\n *     x.jump();\n *     x.walk();\n *     x instanceof Thing && x instanceof Person && x instanceof Jumper;\n *\n * @param {Function} targetFn\n * @param {Function} originFn\n * @throws {Error} If target already inherits from origin\n */\noo.inheritClass = function ( targetFn, originFn ) {\n\tvar targetConstructor;\n\n\tif ( !originFn ) {\n\t\tthrow new Error( 'inheritClass: Origin is not a function (actually ' + originFn + ')' );\n\t}\n\tif ( targetFn.prototype instanceof originFn ) {\n\t\tthrow new Error( 'inheritClass: Target already inherits from origin' );\n\t}\n\n\ttargetConstructor = targetFn.prototype.constructor;\n\n\t// Using ['super'] instead of .super because 'super' is not supported\n\t// by IE 8 and below (bug 63303).\n\t// Provide .parent as alias for code supporting older browsers which\n\t// allows people to comply with their style guide.\n\t// eslint-disable-next-line dot-notation\n\ttargetFn[ 'super' ] = targetFn.parent = originFn;\n\n\ttargetFn.prototype = Object.create( originFn.prototype, {\n\t\t// Restore constructor property of targetFn\n\t\tconstructor: {\n\t\t\tvalue: targetConstructor,\n\t\t\tenumerable: false,\n\t\t\twritable: true,\n\t\t\tconfigurable: true\n\t\t}\n\t} );\n\n\t// Extend static properties - always initialize both sides\n\too.initClass( originFn );\n\ttargetFn.static = Object.create( originFn.static );\n};\n\n/**\n * Copy over *own* prototype properties of a mixin.\n *\n * The 'constructor' (whether implicit or explicit) is not copied over.\n *\n * This does not create inheritance to the origin. If you need inheritance,\n * use OO.inheritClass instead.\n *\n * Beware: This can redefine a prototype property, call before setting your prototypes.\n *\n * Beware: Don't call before OO.inheritClass.\n *\n *     function Foo() {}\n *     function Context() {}\n *\n *     // Avoid repeating this code\n *     function ContextLazyLoad() {}\n *     ContextLazyLoad.prototype.getContext = function () {\n *         if ( !this.context ) {\n *             this.context = new Context();\n *         }\n *         return this.context;\n *     };\n *\n *     function FooBar() {}\n *     OO.inheritClass( FooBar, Foo );\n *     OO.mixinClass( FooBar, ContextLazyLoad );\n *\n * @param {Function} targetFn\n * @param {Function} originFn\n */\noo.mixinClass = function ( targetFn, originFn ) {\n\tvar key;\n\n\tif ( !originFn ) {\n\t\tthrow new Error( 'mixinClass: Origin is not a function (actually ' + originFn + ')' );\n\t}\n\n\t// Copy prototype properties\n\tfor ( key in originFn.prototype ) {\n\t\tif ( key !== 'constructor' && hasOwn.call( originFn.prototype, key ) ) {\n\t\t\ttargetFn.prototype[ key ] = originFn.prototype[ key ];\n\t\t}\n\t}\n\n\t// Copy static properties - always initialize both sides\n\too.initClass( targetFn );\n\tif ( originFn.static ) {\n\t\tfor ( key in originFn.static ) {\n\t\t\tif ( hasOwn.call( originFn.static, key ) ) {\n\t\t\t\ttargetFn.static[ key ] = originFn.static[ key ];\n\t\t\t}\n\t\t}\n\t} else {\n\t\too.initClass( originFn );\n\t}\n};\n\n/**\n * Test whether one class is a subclass of another, without instantiating it.\n *\n * Every class is considered a subclass of Object and of itself.\n *\n * @param {Function} testFn The class to be tested\n * @param {Function} baseFn The base class\n * @return {boolean} Whether testFn is a subclass of baseFn (or equal to it)\n */\noo.isSubclass = function ( testFn, baseFn ) {\n\treturn testFn === baseFn || testFn.prototype instanceof baseFn;\n};\n\n/* Object Methods */\n\n/**\n * Get a deeply nested property of an object using variadic arguments, protecting against\n * undefined property errors.\n *\n * `quux = OO.getProp( obj, 'foo', 'bar', 'baz' );` is equivalent to `quux = obj.foo.bar.baz;`\n * except that the former protects against JS errors if one of the intermediate properties\n * is undefined. Instead of throwing an error, this function will return undefined in\n * that case.\n *\n * @param {Object} obj\n * @param {...Mixed} [keys]\n * @return {Object|undefined} obj[arguments[1]][arguments[2]].... or undefined\n */\noo.getProp = function ( obj ) {\n\tvar i,\n\t\tretval = obj;\n\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\tif ( retval === undefined || retval === null ) {\n\t\t\t// Trying to access a property of undefined or null causes an error\n\t\t\treturn undefined;\n\t\t}\n\t\tretval = retval[ arguments[ i ] ];\n\t}\n\treturn retval;\n};\n\n/**\n * Set a deeply nested property of an object using variadic arguments, protecting against\n * undefined property errors.\n *\n * `oo.setProp( obj, 'foo', 'bar', 'baz' );` is equivalent to `obj.foo.bar = baz;` except that\n * the former protects against JS errors if one of the intermediate properties is\n * undefined. Instead of throwing an error, undefined intermediate properties will be\n * initialized to an empty object. If an intermediate property is not an object, or if obj itself\n * is not an object, this function will silently abort.\n *\n * @param {Object} obj\n * @param {...Mixed} [keys]\n * @param {Mixed} [value]\n */\noo.setProp = function ( obj ) {\n\tvar i,\n\t\tprop = obj;\n\tif ( Object( obj ) !== obj || arguments.length < 2 ) {\n\t\treturn;\n\t}\n\tfor ( i = 1; i < arguments.length - 2; i++ ) {\n\t\tif ( prop[ arguments[ i ] ] === undefined ) {\n\t\t\tprop[ arguments[ i ] ] = {};\n\t\t}\n\t\tif ( Object( prop[ arguments[ i ] ] ) !== prop[ arguments[ i ] ] ) {\n\t\t\treturn;\n\t\t}\n\t\tprop = prop[ arguments[ i ] ];\n\t}\n\tprop[ arguments[ arguments.length - 2 ] ] = arguments[ arguments.length - 1 ];\n};\n\n/**\n * Delete a deeply nested property of an object using variadic arguments, protecting against\n * undefined property errors, and deleting resulting empty objects.\n *\n * @param {Object} obj\n * @param {...Mixed} [keys]\n */\noo.deleteProp = function ( obj ) {\n\tvar i,\n\t\tprop = obj,\n\t\tprops = [ prop ];\n\tif ( Object( obj ) !== obj || arguments.length < 2 ) {\n\t\treturn;\n\t}\n\tfor ( i = 1; i < arguments.length - 1; i++ ) {\n\t\tif ( prop[ arguments[ i ] ] === undefined || Object( prop[ arguments[ i ] ] ) !== prop[ arguments[ i ] ] ) {\n\t\t\treturn;\n\t\t}\n\t\tprop = prop[ arguments[ i ] ];\n\t\tprops.push( prop );\n\t}\n\tdelete prop[ arguments[ i ] ];\n\t// Walk back through props removing any plain empty objects\n\twhile ( ( prop = props.pop() ) && oo.isPlainObject( prop ) && !Object.keys( prop ).length ) {\n\t\tdelete props[ props.length - 1 ][ arguments[ props.length ] ];\n\t}\n};\n\n/**\n * Create a new object that is an instance of the same\n * constructor as the input, inherits from the same object\n * and contains the same own properties.\n *\n * This makes a shallow non-recursive copy of own properties.\n * To create a recursive copy of plain objects, use #copy.\n *\n *     var foo = new Person( mom, dad );\n *     foo.setAge( 21 );\n *     var foo2 = OO.cloneObject( foo );\n *     foo.setAge( 22 );\n *\n *     // Then\n *     foo2 !== foo; // true\n *     foo2 instanceof Person; // true\n *     foo2.getAge(); // 21\n *     foo.getAge(); // 22\n *\n * @param {Object} origin\n * @return {Object} Clone of origin\n */\noo.cloneObject = function ( origin ) {\n\tvar key, r;\n\n\tr = Object.create( origin.constructor.prototype );\n\n\tfor ( key in origin ) {\n\t\tif ( hasOwn.call( origin, key ) ) {\n\t\t\tr[ key ] = origin[ key ];\n\t\t}\n\t}\n\n\treturn r;\n};\n\n/**\n * Get an array of all property values in an object.\n *\n * @param {Object} obj Object to get values from\n * @return {Array} List of object values\n */\noo.getObjectValues = function ( obj ) {\n\tvar key, values;\n\n\tif ( obj !== Object( obj ) ) {\n\t\tthrow new TypeError( 'Called on non-object' );\n\t}\n\n\tvalues = [];\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tvalues[ values.length ] = obj[ key ];\n\t\t}\n\t}\n\n\treturn values;\n};\n\n/**\n * Use binary search to locate an element in a sorted array.\n *\n * searchFunc is given an element from the array. `searchFunc(elem)` must return a number\n * above 0 if the element we're searching for is to the right of (has a higher index than) elem,\n * below 0 if it is to the left of elem, or zero if it's equal to elem.\n *\n * To search for a specific value with a comparator function (a `function cmp(a,b)` that returns\n * above 0 if `a > b`, below 0 if `a < b`, and 0 if `a == b`), you can use\n * `searchFunc = cmp.bind( null, value )`.\n *\n * @param {Array} arr Array to search in\n * @param {Function} searchFunc Search function\n * @param {boolean} [forInsertion] If not found, return index where val could be inserted\n * @return {number|null} Index where val was found, or null if not found\n */\noo.binarySearch = function ( arr, searchFunc, forInsertion ) {\n\tvar mid, cmpResult,\n\t\tleft = 0,\n\t\tright = arr.length;\n\twhile ( left < right ) {\n\t\t// Equivalent to Math.floor( ( left + right ) / 2 ) but much faster\n\t\t// eslint-disable-next-line no-bitwise\n\t\tmid = ( left + right ) >> 1;\n\t\tcmpResult = searchFunc( arr[ mid ] );\n\t\tif ( cmpResult < 0 ) {\n\t\t\tright = mid;\n\t\t} else if ( cmpResult > 0 ) {\n\t\t\tleft = mid + 1;\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn forInsertion ? right : null;\n};\n\n/**\n * Recursively compare properties between two objects.\n *\n * A false result may be caused by property inequality or by properties in one object missing from\n * the other. An asymmetrical test may also be performed, which checks only that properties in the\n * first object are present in the second object, but not the inverse.\n *\n * If either a or b is null or undefined it will be treated as an empty object.\n *\n * @param {Object|undefined|null} a First object to compare\n * @param {Object|undefined|null} b Second object to compare\n * @param {boolean} [asymmetrical] Whether to check only that a's values are equal to b's\n *  (i.e. a is a subset of b)\n * @return {boolean} If the objects contain the same values as each other\n */\noo.compare = function ( a, b, asymmetrical ) {\n\tvar aValue, bValue, aType, bType, k;\n\n\tif ( a === b ) {\n\t\treturn true;\n\t}\n\n\ta = a || {};\n\tb = b || {};\n\n\tif ( typeof a.nodeType === 'number' && typeof a.isEqualNode === 'function' ) {\n\t\treturn a.isEqualNode( b );\n\t}\n\n\tfor ( k in a ) {\n\t\tif ( !hasOwn.call( a, k ) || a[ k ] === undefined || a[ k ] === b[ k ] ) {\n\t\t\t// Support es3-shim: Without the hasOwn filter, comparing [] to {} will be false in ES3\n\t\t\t// because the shimmed \"forEach\" is enumerable and shows up in Array but not Object.\n\t\t\t// Also ignore undefined values, because there is no conceptual difference between\n\t\t\t// a key that is absent and a key that is present but whose value is undefined.\n\t\t\tcontinue;\n\t\t}\n\n\t\taValue = a[ k ];\n\t\tbValue = b[ k ];\n\t\taType = typeof aValue;\n\t\tbType = typeof bValue;\n\t\tif ( aType !== bType ||\n\t\t\t(\n\t\t\t\t( aType === 'string' || aType === 'number' || aType === 'boolean' ) &&\n\t\t\t\taValue !== bValue\n\t\t\t) ||\n\t\t\t( aValue === Object( aValue ) && !oo.compare( aValue, bValue, true ) ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t// If the check is not asymmetrical, recursing with the arguments swapped will verify our result\n\treturn asymmetrical ? true : oo.compare( b, a, true );\n};\n\n/**\n * Create a plain deep copy of any kind of object.\n *\n * Copies are deep, and will either be an object or an array depending on `source`.\n *\n * @param {Object} source Object to copy\n * @param {Function} [leafCallback] Applied to leaf values after they are cloned but before they are added to the clone\n * @param {Function} [nodeCallback] Applied to all values before they are cloned.  If the nodeCallback returns a value other than undefined, the returned value is used instead of attempting to clone.\n * @return {Object} Copy of source object\n */\noo.copy = function ( source, leafCallback, nodeCallback ) {\n\tvar key, destination;\n\n\tif ( nodeCallback ) {\n\t\t// Extensibility: check before attempting to clone source.\n\t\tdestination = nodeCallback( source );\n\t\tif ( destination !== undefined ) {\n\t\t\treturn destination;\n\t\t}\n\t}\n\n\tif ( Array.isArray( source ) ) {\n\t\t// Array (fall through)\n\t\tdestination = new Array( source.length );\n\t} else if ( source && typeof source.clone === 'function' ) {\n\t\t// Duck type object with custom clone method\n\t\treturn leafCallback ? leafCallback( source.clone() ) : source.clone();\n\t} else if ( source && typeof source.cloneNode === 'function' ) {\n\t\t// DOM Node\n\t\treturn leafCallback ?\n\t\t\tleafCallback( source.cloneNode( true ) ) :\n\t\t\tsource.cloneNode( true );\n\t} else if ( oo.isPlainObject( source ) ) {\n\t\t// Plain objects (fall through)\n\t\tdestination = {};\n\t} else {\n\t\t// Non-plain objects (incl. functions) and primitive values\n\t\treturn leafCallback ? leafCallback( source ) : source;\n\t}\n\n\t// source is an array or a plain object\n\tfor ( key in source ) {\n\t\tdestination[ key ] = oo.copy( source[ key ], leafCallback, nodeCallback );\n\t}\n\n\t// This is an internal node, so we don't apply the leafCallback.\n\treturn destination;\n};\n\n/**\n * Generate a hash of an object based on its name and data.\n *\n * Performance optimization: <http://jsperf.com/ve-gethash-201208#/toJson_fnReplacerIfAoForElse>\n *\n * To avoid two objects with the same values generating different hashes, we utilize the replacer\n * argument of JSON.stringify and sort the object by key as it's being serialized. This may or may\n * not be the fastest way to do this; we should investigate this further.\n *\n * Objects and arrays are hashed recursively. When hashing an object that has a .getHash()\n * function, we call that function and use its return value rather than hashing the object\n * ourselves. This allows classes to define custom hashing.\n *\n * @param {Object} val Object to generate hash for\n * @return {string} Hash of object\n */\noo.getHash = function ( val ) {\n\treturn JSON.stringify( val, oo.getHash.keySortReplacer );\n};\n\n/**\n * Sort objects by key (helper function for OO.getHash).\n *\n * This is a callback passed into JSON.stringify.\n *\n * @method getHash_keySortReplacer\n * @param {string} key Property name of value being replaced\n * @param {Mixed} val Property value to replace\n * @return {Mixed} Replacement value\n */\noo.getHash.keySortReplacer = function ( key, val ) {\n\tvar normalized, keys, i, len;\n\tif ( val && typeof val.getHashObject === 'function' ) {\n\t\t// This object has its own custom hash function, use it\n\t\tval = val.getHashObject();\n\t}\n\tif ( !Array.isArray( val ) && Object( val ) === val ) {\n\t\t// Only normalize objects when the key-order is ambiguous\n\t\t// (e.g. any object not an array).\n\t\tnormalized = {};\n\t\tkeys = Object.keys( val ).sort();\n\t\ti = 0;\n\t\tlen = keys.length;\n\t\tfor ( ; i < len; i += 1 ) {\n\t\t\tnormalized[ keys[ i ] ] = val[ keys[ i ] ];\n\t\t}\n\t\treturn normalized;\n\t} else {\n\t\t// Primitive values and arrays get stable hashes\n\t\t// by default. Lets those be stringified as-is.\n\t\treturn val;\n\t}\n};\n\n/**\n * Get the unique values of an array, removing duplicates\n *\n * @param {Array} arr Array\n * @return {Array} Unique values in array\n */\noo.unique = function ( arr ) {\n\treturn arr.reduce( function ( result, current ) {\n\t\tif ( result.indexOf( current ) === -1 ) {\n\t\t\tresult.push( current );\n\t\t}\n\t\treturn result;\n\t}, [] );\n};\n\n/**\n * Compute the union (duplicate-free merge) of a set of arrays.\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * By building an object (with the values for keys) in parallel with\n * the array, a new item's existence in the union can be computed faster.\n *\n * @param {...Array} arrays Arrays to union\n * @return {Array} Union of the arrays\n */\noo.simpleArrayUnion = function () {\n\tvar i, ilen, arr, j, jlen,\n\t\tobj = {},\n\t\tresult = [];\n\n\tfor ( i = 0, ilen = arguments.length; i < ilen; i++ ) {\n\t\tarr = arguments[ i ];\n\t\tfor ( j = 0, jlen = arr.length; j < jlen; j++ ) {\n\t\t\tif ( !obj[ arr[ j ] ] ) {\n\t\t\t\tobj[ arr[ j ] ] = true;\n\t\t\t\tresult.push( arr[ j ] );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Combine arrays (intersection or difference).\n *\n * An intersection checks the item exists in 'b' while difference checks it doesn't.\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * By building an object (with the values for keys) of 'b' we can\n * compute the result faster.\n *\n * @private\n * @param {Array} a First array\n * @param {Array} b Second array\n * @param {boolean} includeB Whether to items in 'b'\n * @return {Array} Combination (intersection or difference) of arrays\n */\nfunction simpleArrayCombine( a, b, includeB ) {\n\tvar i, ilen, isInB,\n\t\tbObj = {},\n\t\tresult = [];\n\n\tfor ( i = 0, ilen = b.length; i < ilen; i++ ) {\n\t\tbObj[ b[ i ] ] = true;\n\t}\n\n\tfor ( i = 0, ilen = a.length; i < ilen; i++ ) {\n\t\tisInB = !!bObj[ a[ i ] ];\n\t\tif ( isInB === includeB ) {\n\t\t\tresult.push( a[ i ] );\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Compute the intersection of two arrays (items in both arrays).\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * @param {Array} a First array\n * @param {Array} b Second array\n * @return {Array} Intersection of arrays\n */\noo.simpleArrayIntersection = function ( a, b ) {\n\treturn simpleArrayCombine( a, b, true );\n};\n\n/**\n * Compute the difference of two arrays (items in 'a' but not 'b').\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * @param {Array} a First array\n * @param {Array} b Second array\n * @return {Array} Intersection of arrays\n */\noo.simpleArrayDifference = function ( a, b ) {\n\treturn simpleArrayCombine( a, b, false );\n};\n\n/* global hasOwn, toString */\n\n/**\n * Assert whether a value is a plain object or not.\n *\n * @member OO\n * @param {Mixed} obj\n * @return {boolean}\n */\noo.isPlainObject = function ( obj ) {\n\tvar proto;\n\n\t// Optimise for common case where internal [[Class]] property is not \"Object\"\n\tif ( !obj || toString.call( obj ) !== '[object Object]' ) {\n\t\treturn false;\n\t}\n\n\tproto = Object.getPrototypeOf( obj );\n\n\t// Objects without prototype (e.g., `Object.create( null )`) are considered plain\n\tif ( !proto ) {\n\t\treturn true;\n\t}\n\n\t// The 'isPrototypeOf' method is set on Object.prototype.\n\treturn hasOwn.call( proto, 'isPrototypeOf' );\n};\n\n/* global hasOwn */\n\n( function () {\n\n\t/**\n\t * @class OO.EventEmitter\n\t *\n\t * @constructor\n\t */\n\too.EventEmitter = function OoEventEmitter() {\n\t\t// Properties\n\n\t\t/**\n\t\t * Storage of bound event handlers by event name.\n\t\t *\n\t\t * @property\n\t\t */\n\t\tthis.bindings = {};\n\t};\n\n\too.initClass( oo.EventEmitter );\n\n\t/* Private helper functions */\n\n\t/**\n\t * Validate a function or method call in a context\n\t *\n\t * For a method name, check that it names a function in the context object\n\t *\n\t * @private\n\t * @param {Function|string} method Function or method name\n\t * @param {Mixed} context The context of the call\n\t * @throws {Error} A method name is given but there is no context\n\t * @throws {Error} In the context object, no property exists with the given name\n\t * @throws {Error} In the context object, the named property is not a function\n\t */\n\tfunction validateMethod( method, context ) {\n\t\t// Validate method and context\n\t\tif ( typeof method === 'string' ) {\n\t\t\t// Validate method\n\t\t\tif ( context === undefined || context === null ) {\n\t\t\t\tthrow new Error( 'Method name \"' + method + '\" has no context.' );\n\t\t\t}\n\t\t\tif ( typeof context[ method ] !== 'function' ) {\n\t\t\t\t// Technically the property could be replaced by a function before\n\t\t\t\t// call time. But this probably signals a typo.\n\t\t\t\tthrow new Error( 'Property \"' + method + '\" is not a function' );\n\t\t\t}\n\t\t} else if ( typeof method !== 'function' ) {\n\t\t\tthrow new Error( 'Invalid callback. Function or method name expected.' );\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {OO.EventEmitter} ee\n\t * @param {Function|string} method Function or method name\n\t * @param {Object} binding\n\t */\n\tfunction addBinding( ee, event, binding ) {\n\t\tvar bindings;\n\t\t// Auto-initialize bindings list\n\t\tif ( hasOwn.call( ee.bindings, event ) ) {\n\t\t\tbindings = ee.bindings[ event ];\n\t\t} else {\n\t\t\tbindings = ee.bindings[ event ] = [];\n\t\t}\n\t\t// Add binding\n\t\tbindings.push( binding );\n\t}\n\n\t/* Methods */\n\n\t/**\n\t * Add a listener to events of a specific event.\n\t *\n\t * The listener can be a function or the string name of a method; if the latter, then the\n\t * name lookup happens at the time the listener is called.\n\t *\n\t * @param {string} event Type of event to listen to\n\t * @param {Function|string} method Function or method name to call when event occurs\n\t * @param {Array} [args] Arguments to pass to listener, will be prepended to emitted arguments\n\t * @param {Object} [context=null] Context object for function or method call\n\t * @throws {Error} Listener argument is not a function or a valid method name\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.on = function ( event, method, args, context ) {\n\t\tvalidateMethod( method, context );\n\n\t\t// Ensure consistent object shape (optimisation)\n\t\taddBinding( this, event, {\n\t\t\tmethod: method,\n\t\t\targs: args,\n\t\t\tcontext: ( arguments.length < 4 ) ? null : context,\n\t\t\tonce: false\n\t\t} );\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add a one-time listener to a specific event.\n\t *\n\t * @param {string} event Type of event to listen to\n\t * @param {Function} listener Listener to call when event occurs\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.once = function ( event, listener ) {\n\t\tvalidateMethod( listener );\n\n\t\t// Ensure consistent object shape (optimisation)\n\t\taddBinding( this, event, {\n\t\t\tmethod: listener,\n\t\t\targs: undefined,\n\t\t\tcontext: null,\n\t\t\tonce: true\n\t\t} );\n\t\treturn this;\n\t};\n\n\t/**\n\t * Remove a specific listener from a specific event.\n\t *\n\t * @param {string} event Type of event to remove listener from\n\t * @param {Function|string} [method] Listener to remove. Must be in the same form as was passed\n\t * to \"on\". Omit to remove all listeners.\n\t * @param {Object} [context=null] Context object function or method call\n\t * @chainable\n\t * @throws {Error} Listener argument is not a function or a valid method name\n\t */\n\too.EventEmitter.prototype.off = function ( event, method, context ) {\n\t\tvar i, bindings;\n\n\t\tif ( arguments.length === 1 ) {\n\t\t\t// Remove all bindings for event\n\t\t\tdelete this.bindings[ event ];\n\t\t\treturn this;\n\t\t}\n\n\t\tvalidateMethod( method, context );\n\n\t\tif ( !hasOwn.call( this.bindings, event ) || !this.bindings[ event ].length ) {\n\t\t\t// No matching bindings\n\t\t\treturn this;\n\t\t}\n\n\t\t// Default to null context\n\t\tif ( arguments.length < 3 ) {\n\t\t\tcontext = null;\n\t\t}\n\n\t\t// Remove matching handlers\n\t\tbindings = this.bindings[ event ];\n\t\ti = bindings.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( bindings[ i ].method === method && bindings[ i ].context === context ) {\n\t\t\t\tbindings.splice( i, 1 );\n\t\t\t}\n\t\t}\n\n\t\t// Cleanup if now empty\n\t\tif ( bindings.length === 0 ) {\n\t\t\tdelete this.bindings[ event ];\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Emit an event.\n\t *\n\t * @param {string} event Type of event\n\t * @param {...Mixed} args First in a list of variadic arguments passed to event handler (optional)\n\t * @return {boolean} Whether the event was handled by at least one listener\n\t */\n\too.EventEmitter.prototype.emit = function ( event ) {\n\t\tvar args = [],\n\t\t\ti, len, binding, bindings, method;\n\n\t\tif ( hasOwn.call( this.bindings, event ) ) {\n\t\t\t// Slicing ensures that we don't get tripped up by event handlers that add/remove bindings\n\t\t\tbindings = this.bindings[ event ].slice();\n\t\t\tfor ( i = 1, len = arguments.length; i < len; i++ ) {\n\t\t\t\targs.push( arguments[ i ] );\n\t\t\t}\n\t\t\tfor ( i = 0, len = bindings.length; i < len; i++ ) {\n\t\t\t\tbinding = bindings[ i ];\n\t\t\t\tif ( typeof binding.method === 'string' ) {\n\t\t\t\t\t// Lookup method by name (late binding)\n\t\t\t\t\tmethod = binding.context[ binding.method ];\n\t\t\t\t} else {\n\t\t\t\t\tmethod = binding.method;\n\t\t\t\t}\n\t\t\t\tif ( binding.once ) {\n\t\t\t\t\t// Must unbind before calling method to avoid\n\t\t\t\t\t// any nested triggers.\n\t\t\t\t\tthis.off( event, method );\n\t\t\t\t}\n\t\t\t\tmethod.apply(\n\t\t\t\t\tbinding.context,\n\t\t\t\t\tbinding.args ? binding.args.concat( args ) : args\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Connect event handlers to an object.\n\t *\n\t * @param {Object} context Object to call methods on when events occur\n\t * @param {Object.<string,string>|Object.<string,Function>|Object.<string,Array>} methods List of\n\t *  event bindings keyed by event name containing either method names, functions or arrays containing\n\t *  method name or function followed by a list of arguments to be passed to callback before emitted\n\t *  arguments.\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.connect = function ( context, methods ) {\n\t\tvar method, args, event;\n\n\t\tfor ( event in methods ) {\n\t\t\tmethod = methods[ event ];\n\t\t\t// Allow providing additional args\n\t\t\tif ( Array.isArray( method ) ) {\n\t\t\t\targs = method.slice( 1 );\n\t\t\t\tmethod = method[ 0 ];\n\t\t\t} else {\n\t\t\t\targs = [];\n\t\t\t}\n\t\t\t// Add binding\n\t\t\tthis.on( event, method, args, context );\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Disconnect event handlers from an object.\n\t *\n\t * @param {Object} context Object to disconnect methods from\n\t * @param {Object.<string,string>|Object.<string,Function>|Object.<string,Array>} [methods] List of\n\t *  event bindings keyed by event name. Values can be either method names, functions or arrays\n\t *  containing a method name.\n\t *  NOTE: To allow matching call sites with connect(), array values are allowed to contain the\n\t *  parameters as well, but only the method name is used to find bindings. Tt is discouraged to\n\t *  have multiple bindings for the same event to the same listener, but if used (and only the\n\t *  parameters vary), disconnecting one variation of (event name, event listener, parameters)\n\t *  will disconnect other variations as well.\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.disconnect = function ( context, methods ) {\n\t\tvar i, event, method, bindings;\n\n\t\tif ( methods ) {\n\t\t\t// Remove specific connections to the context\n\t\t\tfor ( event in methods ) {\n\t\t\t\tmethod = methods[ event ];\n\t\t\t\tif ( Array.isArray( method ) ) {\n\t\t\t\t\tmethod = method[ 0 ];\n\t\t\t\t}\n\t\t\t\tthis.off( event, method, context );\n\t\t\t}\n\t\t} else {\n\t\t\t// Remove all connections to the context\n\t\t\tfor ( event in this.bindings ) {\n\t\t\t\tbindings = this.bindings[ event ];\n\t\t\t\ti = bindings.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t// bindings[i] may have been removed by the previous step's\n\t\t\t\t\t// this.off so check it still exists\n\t\t\t\t\tif ( bindings[ i ] && bindings[ i ].context === context ) {\n\t\t\t\t\t\tthis.off( event, bindings[ i ].method, context );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n}() );\n\n( function () {\n\n\t/**\n\t * Contain and manage a list of OO.EventEmitter items.\n\t *\n\t * Aggregates and manages their events collectively.\n\t *\n\t * This mixin must be used in a class that also mixes in OO.EventEmitter.\n\t *\n\t * @abstract\n\t * @class OO.EmitterList\n\t * @constructor\n\t */\n\too.EmitterList = function OoEmitterList() {\n\t\tthis.items = [];\n\t\tthis.aggregateItemEvents = {};\n\t};\n\n\t/* Events */\n\n\t/**\n\t * Item has been added\n\t *\n\t * @event add\n\t * @param {OO.EventEmitter} item Added item\n\t * @param {number} index Index items were added at\n\t */\n\n\t/**\n\t * Item has been moved to a new index\n\t *\n\t * @event move\n\t * @param {OO.EventEmitter} item Moved item\n\t * @param {number} index Index item was moved to\n\t * @param {number} oldIndex The original index the item was in\n\t */\n\n\t/**\n\t * Item has been removed\n\t *\n\t * @event remove\n\t * @param {OO.EventEmitter} item Removed item\n\t * @param {number} index Index the item was removed from\n\t */\n\n\t/**\n\t * @event clear The list has been cleared of items\n\t */\n\n\t/* Methods */\n\n\t/**\n\t * Normalize requested index to fit into the bounds of the given array.\n\t *\n\t * @private\n\t * @static\n\t * @param {Array} arr Given array\n\t * @param {number|undefined} index Requested index\n\t * @return {number} Normalized index\n\t */\n\tfunction normalizeArrayIndex( arr, index ) {\n\t\treturn ( index === undefined || index < 0 || index >= arr.length ) ?\n\t\t\tarr.length :\n\t\t\tindex;\n\t}\n\n\t/**\n\t * Get all items.\n\t *\n\t * @return {OO.EventEmitter[]} Items in the list\n\t */\n\too.EmitterList.prototype.getItems = function () {\n\t\treturn this.items.slice( 0 );\n\t};\n\n\t/**\n\t * Get the index of a specific item.\n\t *\n\t * @param {OO.EventEmitter} item Requested item\n\t * @return {number} Index of the item\n\t */\n\too.EmitterList.prototype.getItemIndex = function ( item ) {\n\t\treturn this.items.indexOf( item );\n\t};\n\n\t/**\n\t * Get number of items.\n\t *\n\t * @return {number} Number of items in the list\n\t */\n\too.EmitterList.prototype.getItemCount = function () {\n\t\treturn this.items.length;\n\t};\n\n\t/**\n\t * Check if a list contains no items.\n\t *\n\t * @return {boolean} Group is empty\n\t */\n\too.EmitterList.prototype.isEmpty = function () {\n\t\treturn !this.items.length;\n\t};\n\n\t/**\n\t * Aggregate the events emitted by the group.\n\t *\n\t * When events are aggregated, the group will listen to all contained items for the event,\n\t * and then emit the event under a new name. The new event will contain an additional leading\n\t * parameter containing the item that emitted the original event. Other arguments emitted from\n\t * the original event are passed through.\n\t *\n\t * @param {Object.<string,string|null>} events An object keyed by the name of the event that should be\n\t *  aggregated  (e.g., ‘click’) and the value of the new name to use (e.g., ‘groupClick’).\n\t *  A `null` value will remove aggregated events.\n\n\t * @throws {Error} If aggregation already exists\n\t */\n\too.EmitterList.prototype.aggregate = function ( events ) {\n\t\tvar i, item, add, remove, itemEvent, groupEvent;\n\n\t\tfor ( itemEvent in events ) {\n\t\t\tgroupEvent = events[ itemEvent ];\n\n\t\t\t// Remove existing aggregated event\n\t\t\tif ( Object.prototype.hasOwnProperty.call( this.aggregateItemEvents, itemEvent ) ) {\n\t\t\t\t// Don't allow duplicate aggregations\n\t\t\t\tif ( groupEvent ) {\n\t\t\t\t\tthrow new Error( 'Duplicate item event aggregation for ' + itemEvent );\n\t\t\t\t}\n\t\t\t\t// Remove event aggregation from existing items\n\t\t\t\tfor ( i = 0; i < this.items.length; i++ ) {\n\t\t\t\t\titem = this.items[ i ];\n\t\t\t\t\tif ( item.connect && item.disconnect ) {\n\t\t\t\t\t\tremove = {};\n\t\t\t\t\t\tremove[ itemEvent ] = [ 'emit', this.aggregateItemEvents[ itemEvent ], item ];\n\t\t\t\t\t\titem.disconnect( this, remove );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Prevent future items from aggregating event\n\t\t\t\tdelete this.aggregateItemEvents[ itemEvent ];\n\t\t\t}\n\n\t\t\t// Add new aggregate event\n\t\t\tif ( groupEvent ) {\n\t\t\t\t// Make future items aggregate event\n\t\t\t\tthis.aggregateItemEvents[ itemEvent ] = groupEvent;\n\t\t\t\t// Add event aggregation to existing items\n\t\t\t\tfor ( i = 0; i < this.items.length; i++ ) {\n\t\t\t\t\titem = this.items[ i ];\n\t\t\t\t\tif ( item.connect && item.disconnect ) {\n\t\t\t\t\t\tadd = {};\n\t\t\t\t\t\tadd[ itemEvent ] = [ 'emit', groupEvent, item ];\n\t\t\t\t\t\titem.connect( this, add );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Add items to the list.\n\t *\n\t * @param {OO.EventEmitter|OO.EventEmitter[]} items Item to add or\n\t *  an array of items to add\n\t * @param {number} [index] Index to add items at. If no index is\n\t *  given, or if the index that is given is invalid, the item\n\t *  will be added at the end of the list.\n\t * @chainable\n\t * @fires add\n\t * @fires move\n\t */\n\too.EmitterList.prototype.addItems = function ( items, index ) {\n\t\tvar i, oldIndex;\n\n\t\tif ( !Array.isArray( items ) ) {\n\t\t\titems = [ items ];\n\t\t}\n\n\t\tif ( items.length === 0 ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tindex = normalizeArrayIndex( this.items, index );\n\t\tfor ( i = 0; i < items.length; i++ ) {\n\t\t\toldIndex = this.items.indexOf( items[ i ] );\n\t\t\tif ( oldIndex !== -1 ) {\n\t\t\t\t// Move item to new index\n\t\t\t\tindex = this.moveItem( items[ i ], index );\n\t\t\t\tthis.emit( 'move', items[ i ], index, oldIndex );\n\t\t\t} else {\n\t\t\t\t// insert item at index\n\t\t\t\tindex = this.insertItem( items[ i ], index );\n\t\t\t\tthis.emit( 'add', items[ i ], index );\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Move an item from its current position to a new index.\n\t *\n\t * The item is expected to exist in the list. If it doesn't,\n\t * the method will throw an exception.\n\t *\n\t * @private\n\t * @param {OO.EventEmitter} item Items to add\n\t * @param {number} newIndex Index to move the item to\n\t * @return {number} The index the item was moved to\n\t * @throws {Error} If item is not in the list\n\t */\n\too.EmitterList.prototype.moveItem = function ( item, newIndex ) {\n\t\tvar existingIndex = this.items.indexOf( item );\n\n\t\tif ( existingIndex === -1 ) {\n\t\t\tthrow new Error( 'Item cannot be moved, because it is not in the list.' );\n\t\t}\n\n\t\tnewIndex = normalizeArrayIndex( this.items, newIndex );\n\n\t\t// Remove the item from the current index\n\t\tthis.items.splice( existingIndex, 1 );\n\n\t\t// If necessary, adjust new index after removal\n\t\tif ( existingIndex < newIndex ) {\n\t\t\tnewIndex--;\n\t\t}\n\n\t\t// Move the item to the new index\n\t\tthis.items.splice( newIndex, 0, item );\n\n\t\treturn newIndex;\n\t};\n\n\t/**\n\t * Utility method to insert an item into the list, and\n\t * connect it to aggregate events.\n\t *\n\t * Don't call this directly unless you know what you're doing.\n\t * Use #addItems instead.\n\t *\n\t * This method can be extended in child classes to produce\n\t * different behavior when an item is inserted. For example,\n\t * inserted items may also be attached to the DOM or may\n\t * interact with some other nodes in certain ways. Extending\n\t * this method is allowed, but if overriden, the aggregation\n\t * of events must be preserved, or behavior of emitted events\n\t * will be broken.\n\t *\n\t * If you are extending this method, please make sure the\n\t * parent method is called.\n\t *\n\t * @protected\n\t * @param {OO.EventEmitter} item Items to add\n\t * @param {number} index Index to add items at\n\t * @return {number} The index the item was added at\n\t */\n\too.EmitterList.prototype.insertItem = function ( item, index ) {\n\t\tvar events, event;\n\n\t\t// Add the item to event aggregation\n\t\tif ( item.connect && item.disconnect ) {\n\t\t\tevents = {};\n\t\t\tfor ( event in this.aggregateItemEvents ) {\n\t\t\t\tevents[ event ] = [ 'emit', this.aggregateItemEvents[ event ], item ];\n\t\t\t}\n\t\t\titem.connect( this, events );\n\t\t}\n\n\t\tindex = normalizeArrayIndex( this.items, index );\n\n\t\t// Insert into items array\n\t\tthis.items.splice( index, 0, item );\n\t\treturn index;\n\t};\n\n\t/**\n\t * Remove items.\n\t *\n\t * @param {OO.EventEmitter[]} items Items to remove\n\t * @chainable\n\t * @fires remove\n\t */\n\too.EmitterList.prototype.removeItems = function ( items ) {\n\t\tvar i, item, index;\n\n\t\tif ( !Array.isArray( items ) ) {\n\t\t\titems = [ items ];\n\t\t}\n\n\t\tif ( items.length === 0 ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Remove specific items\n\t\tfor ( i = 0; i < items.length; i++ ) {\n\t\t\titem = items[ i ];\n\t\t\tindex = this.items.indexOf( item );\n\t\t\tif ( index !== -1 ) {\n\t\t\t\tif ( item.connect && item.disconnect ) {\n\t\t\t\t\t// Disconnect all listeners from the item\n\t\t\t\t\titem.disconnect( this );\n\t\t\t\t}\n\t\t\t\tthis.items.splice( index, 1 );\n\t\t\t\tthis.emit( 'remove', item, index );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Clear all items\n\t *\n\t * @chainable\n\t * @fires clear\n\t */\n\too.EmitterList.prototype.clearItems = function () {\n\t\tvar i, item,\n\t\t\tcleared = this.items.splice( 0, this.items.length );\n\n\t\t// Disconnect all items\n\t\tfor ( i = 0; i < cleared.length; i++ ) {\n\t\t\titem = cleared[ i ];\n\t\t\tif ( item.connect && item.disconnect ) {\n\t\t\t\titem.disconnect( this );\n\t\t\t}\n\t\t}\n\n\t\tthis.emit( 'clear' );\n\n\t\treturn this;\n\t};\n\n}() );\n\n/**\n * Manage a sorted list of OO.EmitterList objects.\n *\n * The sort order is based on a callback that compares two items. The return value of\n * callback( a, b ) must be less than zero if a < b, greater than zero if a > b, and zero\n * if a is equal to b. The callback should only return zero if the two objects are\n * considered equal.\n *\n * When an item changes in a way that could affect their sorting behavior, it must\n * emit the itemSortChange event. This will cause it to be re-sorted automatically.\n *\n * This mixin must be used in a class that also mixes in OO.EventEmitter.\n *\n * @abstract\n * @class OO.SortedEmitterList\n * @mixins OO.EmitterList\n * @constructor\n * @param {Function} sortingCallback Callback that compares two items.\n */\noo.SortedEmitterList = function OoSortedEmitterList( sortingCallback ) {\n\t// Mixin constructors\n\too.EmitterList.call( this );\n\n\tthis.sortingCallback = sortingCallback;\n\n\t// Listen to sortChange event and make sure\n\t// we re-sort the changed item when that happens\n\tthis.aggregate( {\n\t\tsortChange: 'itemSortChange'\n\t} );\n\n\tthis.connect( this, {\n\t\titemSortChange: 'onItemSortChange'\n\t} );\n};\n\noo.mixinClass( oo.SortedEmitterList, oo.EmitterList );\n\n/* Events */\n\n/**\n * An item has changed properties that affect its sort positioning\n * inside the list.\n *\n * @private\n * @event itemSortChange\n */\n\n/* Methods */\n\n/**\n * Handle a case where an item changed a property that relates\n * to its sorted order\n *\n * @param {OO.EventEmitter} item Item in the list\n */\noo.SortedEmitterList.prototype.onItemSortChange = function ( item ) {\n\t// Remove the item\n\tthis.removeItems( item );\n\t// Re-add the item so it is in the correct place\n\tthis.addItems( item );\n};\n\n/**\n * Change the sorting callback for this sorted list.\n *\n * The callback receives two items. The return value of callback(a, b) must be less than zero\n * if a < b, greater than zero if a > b, and zero if a is equal to b.\n *\n * @param {Function} sortingCallback Sorting callback\n */\noo.SortedEmitterList.prototype.setSortingCallback = function ( sortingCallback ) {\n\tvar items = this.getItems();\n\n\tthis.sortingCallback = sortingCallback;\n\n\t// Empty the list\n\tthis.clearItems();\n\t// Re-add the items in the new order\n\tthis.addItems( items );\n};\n\n/**\n * Add items to the sorted list.\n *\n * @chainable\n * @param {OO.EventEmitter|OO.EventEmitter[]} items Item to add or\n *  an array of items to add\n */\noo.SortedEmitterList.prototype.addItems = function ( items ) {\n\tvar index, i, insertionIndex;\n\n\tif ( !Array.isArray( items ) ) {\n\t\titems = [ items ];\n\t}\n\n\tif ( items.length === 0 ) {\n\t\treturn this;\n\t}\n\n\tfor ( i = 0; i < items.length; i++ ) {\n\t\t// Find insertion index\n\t\tinsertionIndex = this.findInsertionIndex( items[ i ] );\n\n\t\t// Check if the item exists using the sorting callback\n\t\t// and remove it first if it exists\n\t\tif (\n\t\t\t// First make sure the insertion index is not at the end\n\t\t\t// of the list (which means it does not point to any actual\n\t\t\t// items)\n\t\t\tinsertionIndex <= this.items.length &&\n\t\t\t// Make sure there actually is an item in this index\n\t\t\tthis.items[ insertionIndex ] &&\n\t\t\t// The callback returns 0 if the items are equal\n\t\t\tthis.sortingCallback( this.items[ insertionIndex ], items[ i ] ) === 0\n\t\t) {\n\t\t\t// Remove the existing item\n\t\t\tthis.removeItems( this.items[ insertionIndex ] );\n\t\t}\n\n\t\t// Insert item at the insertion index\n\t\tindex = this.insertItem( items[ i ], insertionIndex );\n\t\tthis.emit( 'add', items[ i ], index );\n\t}\n\n\treturn this;\n};\n\n/**\n * Find the index a given item should be inserted at. If the item is already\n * in the list, this will return the index where the item currently is.\n *\n * @param {OO.EventEmitter} item Items to insert\n * @return {number} The index the item should be inserted at\n */\noo.SortedEmitterList.prototype.findInsertionIndex = function ( item ) {\n\tvar list = this;\n\n\treturn oo.binarySearch(\n\t\tthis.items,\n\t\t// Fake a this.sortingCallback.bind( null, item ) call here\n\t\t// otherwise this doesn't pass tests in phantomJS\n\t\tfunction ( otherItem ) {\n\t\t\treturn list.sortingCallback( item, otherItem );\n\t\t},\n\t\ttrue\n\t);\n\n};\n\n/* global hasOwn */\n\n/**\n * @class OO.Registry\n * @mixins OO.EventEmitter\n *\n * @constructor\n */\noo.Registry = function OoRegistry() {\n\t// Mixin constructors\n\too.EventEmitter.call( this );\n\n\t// Properties\n\tthis.registry = {};\n};\n\n/* Inheritance */\n\noo.mixinClass( oo.Registry, oo.EventEmitter );\n\n/* Events */\n\n/**\n * @event register\n * @param {string} name\n * @param {Mixed} data\n */\n\n/**\n * @event unregister\n * @param {string} name\n * @param {Mixed} data Data removed from registry\n */\n\n/* Methods */\n\n/**\n * Associate one or more symbolic names with some data.\n *\n * Any existing entry with the same name will be overridden.\n *\n * @param {string|string[]} name Symbolic name or list of symbolic names\n * @param {Mixed} data Data to associate with symbolic name\n * @fires register\n * @throws {Error} Name argument must be a string or array\n */\noo.Registry.prototype.register = function ( name, data ) {\n\tvar i, len;\n\tif ( typeof name === 'string' ) {\n\t\tthis.registry[ name ] = data;\n\t\tthis.emit( 'register', name, data );\n\t} else if ( Array.isArray( name ) ) {\n\t\tfor ( i = 0, len = name.length; i < len; i++ ) {\n\t\t\tthis.register( name[ i ], data );\n\t\t}\n\t} else {\n\t\tthrow new Error( 'Name must be a string or array, cannot be a ' + typeof name );\n\t}\n};\n\n/**\n * Remove one or more symbolic names from the registry\n *\n * @param {string|string[]} name Symbolic name or list of symbolic names\n * @fires unregister\n * @throws {Error} Name argument must be a string or array\n */\noo.Registry.prototype.unregister = function ( name ) {\n\tvar i, len, data;\n\tif ( typeof name === 'string' ) {\n\t\tdata = this.lookup( name );\n\t\tif ( data !== undefined ) {\n\t\t\tdelete this.registry[ name ];\n\t\t\tthis.emit( 'unregister', name, data );\n\t\t}\n\t} else if ( Array.isArray( name ) ) {\n\t\tfor ( i = 0, len = name.length; i < len; i++ ) {\n\t\t\tthis.unregister( name[ i ] );\n\t\t}\n\t} else {\n\t\tthrow new Error( 'Name must be a string or array, cannot be a ' + typeof name );\n\t}\n};\n\n/**\n * Get data for a given symbolic name.\n *\n * @param {string} name Symbolic name\n * @return {Mixed|undefined} Data associated with symbolic name\n */\noo.Registry.prototype.lookup = function ( name ) {\n\tif ( hasOwn.call( this.registry, name ) ) {\n\t\treturn this.registry[ name ];\n\t}\n};\n\n/**\n * @class OO.Factory\n * @extends OO.Registry\n *\n * @constructor\n */\noo.Factory = function OoFactory() {\n\t// Parent constructor\n\too.Factory.super.call( this );\n};\n\n/* Inheritance */\n\noo.inheritClass( oo.Factory, oo.Registry );\n\n/* Methods */\n\n/**\n * Register a constructor with the factory.\n *\n * Classes must have a static `name` property to be registered.\n *\n *     function MyClass() {};\n *     OO.initClass( MyClass );\n *     // Adds a static property to the class defining a symbolic name\n *     MyClass.static.name = 'mine';\n *     // Registers class with factory, available via symbolic name 'mine'\n *     factory.register( MyClass );\n *\n * @param {Function} constructor Constructor to use when creating object\n * @throws {Error} Name must be a string and must not be empty\n * @throws {Error} Constructor must be a function\n */\noo.Factory.prototype.register = function ( constructor ) {\n\tvar name;\n\n\tif ( typeof constructor !== 'function' ) {\n\t\tthrow new Error( 'constructor must be a function, cannot be a ' + typeof constructor );\n\t}\n\tname = constructor.static && constructor.static.name;\n\tif ( typeof name !== 'string' || name === '' ) {\n\t\tthrow new Error( 'Name must be a string and must not be empty' );\n\t}\n\n\t// Parent method\n\too.Factory.super.prototype.register.call( this, name, constructor );\n};\n\n/**\n * Unregister a constructor from the factory.\n *\n * @param {Function} constructor Constructor to unregister\n * @throws {Error} Name must be a string and must not be empty\n * @throws {Error} Constructor must be a function\n */\noo.Factory.prototype.unregister = function ( constructor ) {\n\tvar name;\n\n\tif ( typeof constructor !== 'function' ) {\n\t\tthrow new Error( 'constructor must be a function, cannot be a ' + typeof constructor );\n\t}\n\tname = constructor.static && constructor.static.name;\n\tif ( typeof name !== 'string' || name === '' ) {\n\t\tthrow new Error( 'Name must be a string and must not be empty' );\n\t}\n\n\t// Parent method\n\too.Factory.super.prototype.unregister.call( this, name );\n};\n\n/**\n * Create an object based on a name.\n *\n * Name is used to look up the constructor to use, while all additional arguments are passed to the\n * constructor directly, so leaving one out will pass an undefined to the constructor.\n *\n * @param {string} name Object name\n * @param {...Mixed} [args] Arguments to pass to the constructor\n * @return {Object} The new object\n * @throws {Error} Unknown object name\n */\noo.Factory.prototype.create = function ( name ) {\n\tvar obj, i,\n\t\targs = [],\n\t\tconstructor = this.lookup( name );\n\n\tif ( !constructor ) {\n\t\tthrow new Error( 'No class registered by that name: ' + name );\n\t}\n\n\t// Convert arguments to array and shift the first argument (name) off\n\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\targs.push( arguments[ i ] );\n\t}\n\n\t// We can't use the \"new\" operator with .apply directly because apply needs a\n\t// context. So instead just do what \"new\" does: create an object that inherits from\n\t// the constructor's prototype (which also makes it an \"instanceof\" the constructor),\n\t// then invoke the constructor with the object as context, and return it (ignoring\n\t// the constructor's return value).\n\tobj = Object.create( constructor.prototype );\n\tconstructor.apply( obj, args );\n\treturn obj;\n};\n\n/* eslint-env node */\n\n/* istanbul ignore next */\nif ( typeof module !== 'undefined' && module.exports ) {\n\tmodule.exports = oo;\n} else {\n\tglobal.OO = oo;\n}\n\n}( this ) );\n"]}